---
title: 编辑距离算法
date: 2017-03-10 04:32:45
tags: 算法
categories: 算法
---

前面一篇文章觉得不复杂，当选择**Pick one**的时候，整个世界都崩溃了。文章记录的是现在都两个字符串word1和word2，如何通过插入，删除，替换的方式将字符串从word1转换为word2.计算出这个转换过程的最小步骤。算出这道题后，后面我还在网上找了两个拓展的题。据说是来自*<<程序员编程艺术：面试和算法心得>>*。我也没有读过，并不确定，但是给出了解法。就这三个题，耗费了我整整一天，我已经是个废人了。欢迎读者给出更优秀的答案。该吐槽就吐槽，千万别犹豫。

> Edit Distance
>
> Given two words *word1* and *word2*, find the minimum number of steps required to convert *word1* to *word2*. (each operation is counted as 1 step.)
>
> You have the following 3 operations permitted on a word:
>
> a) Insert a character
> b) Delete a character
> c) Replace a character

<!--more-->

## 解决方案

### 分析

### 实例代码

```java
/**
   *
   * @param word1
   * @param word2
   * @return {@link Integer} 
   * {@// TODO: 2017/3/10 时间复杂度O(n^2) }
   */
  public int minDistance(String word1, String word2) {
    if (word1.equals(word2)) {
      return 0;
    }
    if (word1.length() == 0 || word2.length() == 0) {
      return Math.abs(word1.length() - word2.length());
    }
    // 声明一个两个字符串长度都加一的二维数组
    int[][] dp = new int[word1.length() + 1][word2.length() + 1];
    //  设置水平方向为0-->word1.length+1
    for (int i = 0; i <= word1.length(); i++) {
      dp[i][0] = i;
    }
    //  设置竖直方向为0-->word2.length()
    for (int i = 0; i <= word2.length(); i++) {
      dp[0][i] = i;
    }
    for (int i = 1; i <= word1.length(); i++) {
      for (int j = 1; j <= word2.length(); j++) {
        System.out.println("i:" + i);
        System.out.println("j:" + j);
        if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
          System.out.println("word1的变量当前为:" + word1.charAt(i - 1));
          System.out.println("word2的变量当前为:" + word2.charAt(j - 1));
          System.out.println("dp["+(i - 1)+"]["+(j - 1)+"]:" + dp[i - 1][j - 1]);
          dp[i][j] = dp[i - 1][j - 1];
        } else {
          System.out.println("值不相同");
          System.out.println("dp["+(i - 1)+"]["+(j - 1)+"]:" + dp[i - 1][j - 1]);
          System.out.println("dp["+(i - 1)+"]["+(j)+"]:" + dp[i - 1][j]);
          System.out.println("dp["+(i)+"]["+(j-1)+"]:" + dp[i][j-1]);
          dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
        }
      }
    }
    return dp[word1.length()][word2.length()];
  }
```





## 拓展题目一



> 传统的编辑距离里面有三种操作，即增、删、改，我们现在要讨论的编辑距离只允许两种操作，即增加一个字符、删除一个字符。我们求两个字符串的这种编辑距离，即把一个字符串变成另外一个字符串的最少操作次数。假定每个字符串长度不超过1000，只有大写英文字母组成。

### 分析



### 实例代码



## 拓展题目二

> 有一亿个数，输入一个数，找出与它编辑距离在3以内的数，比如输入6（0110），找出0010等数，数是32位的。



### 分析



### 实例代码

